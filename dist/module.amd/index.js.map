{"version":3,"file":"index.js","sources":["../../src/Router.ts","../../src/WorkManager.ts"],"sourcesContent":["/**\r\n * @author Giuliano Collacchioni @2020\r\n */\r\n\r\nimport { Key} from \"path-to-regexp\";\r\nimport * as qs from \"query-string\";\r\n\r\nimport * as HistoryManager from \"./HistoryManager\";\r\nimport * as NavigationLock from \"./NavigationLock\";\r\nimport * as PathGenerator from \"./PathGenerator\";\r\nimport * as URLManager from \"./URLManager\";\r\n\r\nconst ROUTES: unique symbol = Symbol(\"routes\");\r\nconst REDIRECTIONS: unique symbol = Symbol(\"redirections\");\r\nconst DESTROYED: unique symbol = Symbol(\"destroyed\");\r\n\r\nexport type KeyMap = Map<string, any>;\r\n\r\n/**\r\n * Genera una Map avendo le chiavi e i valori associati in due liste separate\r\n * @param keys\r\n * @param values\r\n */\r\nfunction KeyMapFrom(keys: Array<Key>, values: any[]): Map<string, any> {\r\n    let map: Map<string, any> = new Map();\r\n    keys.forEach((key, index) => {\r\n        map.set(key.name.toString(), values[index]);\r\n    });\r\n    return map;\r\n}\r\n\r\nexport interface ILocation {\r\n    href: string;\r\n    pathname: string;\r\n    hash: string;\r\n    query: string;\r\n    parsedQuery: any;\r\n    hasQueryParam(param: string): boolean;\r\n    getQueryParam(param: string): string | null | undefined;\r\n    addQueryParam(param: string, value: string | null): void;\r\n    removeQueryParam(param: string): void;\r\n    hrefIf(go: string): string;\r\n}\r\nexport interface IRouteCallback {\r\n    (location: ILocation, keymap: KeyMap, redirection: { location: ILocation, keymap: KeyMap } | null): void;\r\n}\r\ninterface IRoute {\r\n    regex: RegExp;\r\n    keys: Array<Key>;\r\n    callback: IRouteCallback;\r\n}\r\ninterface IRedirectionRoute {\r\n    regex: RegExp;\r\n    keys: Array<Key>;\r\n    redirection: string;\r\n}\r\nlet routers: Array<GenericRouter> = [];\r\n\r\nexport function getLocation(href: string = URLManager.get()): ILocation {\r\n    let pathname: string = \"\";\r\n    let hash: string = \"\";\r\n    let query: string = \"\";\r\n    let cachedQuery: { [key: string]: any } | null = null;\r\n    // href = \"/\" + href.replace(/[\\\\\\/]+(?![^(]*[)])/g, \"/\").replace(/^[\\/]+/, \"\").replace(/[\\/]+$/, \"\");\r\n    {\r\n        let split: string[] = href.split(\"#\");\r\n        pathname = split.shift()!;\r\n        hash = split.join(\"#\");\r\n        hash = hash ? \"#\" + hash : \"\";\r\n    }{\r\n        let split: string[] = pathname.split(\"?\");\r\n        pathname = split.shift()!;\r\n        query = split.join(\"?\");\r\n        query = query ? \"?\" + query : \"\";\r\n    }\r\n    pathname = PathGenerator.prepare(pathname);\r\n    return {\r\n        hrefIf: function (go: string): string {\r\n            let oldP: string = pathname;\r\n            let oldH: string = hash;\r\n            let oldQ: string = query;\r\n            this.href = go;\r\n            let hrefIf: string = this.href;\r\n            pathname = oldP;\r\n            hash = oldH;\r\n            query = oldQ;\r\n            return hrefIf;\r\n        },\r\n        get href(): string {\r\n            return pathname + query + hash;\r\n        },\r\n        set href(value: string) {\r\n            if (typeof value !== \"string\") {\r\n                throw new Error(\"href should be a string\");\r\n            }\r\n            if (!value) {\r\n                // refresh\r\n                return;\r\n            }\r\n            // match at start \"//\", \"/\", \"#\" or \"?\"\r\n            let match: RegExpMatchArray | null = value.match(/^([\\/\\\\]{2,})|([\\/\\\\]{1})|([#])|([\\?])/);\r\n            if (match) {\r\n                switch (match[0]) {\r\n                    case \"?\": {\r\n                        query = \"?\" + encodeURI(value.substr(1)).replace(\"#\", \"%23\").replace(\"?\", \"%3F\");\r\n                        break;\r\n                    }\r\n                    case \"#\": {\r\n                        hash = value;\r\n                        break;\r\n                    }\r\n                    case \"/\": {\r\n                        pathname = PathGenerator.prepare(value);\r\n                        hash = \"\";\r\n                        query = \"\";\r\n                        break;\r\n                    }\r\n                    default: {\r\n                        // here only for \"//\", not valid\r\n                        return;\r\n                    }\r\n                }\r\n            } else {\r\n                let path: Array<string> = pathname.split(\"/\");\r\n                // replace last item with the new value\r\n                path.pop();\r\n                path.push(PathGenerator.prepare(value));\r\n                pathname = path.join(\"/\");\r\n                hash = \"\";\r\n                query = \"\";\r\n            }\r\n            // emit?\r\n        },\r\n        get pathname(): string {\r\n            return pathname;\r\n        },\r\n        set pathname(value: string) {\r\n            if (typeof value !== \"string\") {\r\n                throw new Error(\"pathname should be a string\");\r\n            }\r\n            pathname = PathGenerator.prepare(value);\r\n        },\r\n        get hash(): string {\r\n            return hash;\r\n        },\r\n        set hash(value: string) {\r\n            if (typeof value !== \"string\") {\r\n                throw new Error(\"hash should be a string\");\r\n            }\r\n            if (!value) {\r\n                hash = \"\";\r\n                return;\r\n            }\r\n            if (value.indexOf(\"#\") !== 0) {\r\n                value = \"#\" + value;\r\n            }\r\n            hash = value;\r\n        },\r\n        get query(): string {\r\n            return query;\r\n        },\r\n        set query(value: string) {\r\n            if (typeof value !== \"string\") {\r\n                throw new Error(\"query should be a string\");\r\n            }\r\n            cachedQuery = null;\r\n            if (!value) {\r\n                query = \"\";\r\n                return;\r\n            }\r\n            if (value.indexOf(\"?\") !== 0) {\r\n                value = \"?\" + value;\r\n            }\r\n            query = encodeURI(value).replace(\"#\", \"%23\");\r\n        },\r\n        get parsedQuery(): any {\r\n            if (!query) {\r\n                return {};\r\n            }\r\n            if (!cachedQuery) {\r\n                cachedQuery = qs.parse(query.replace(/^\\?/, \"\"));\r\n            }\r\n            return cachedQuery;\r\n        },\r\n        hasQueryParam(param: string): boolean {\r\n            if (!query) {\r\n                return false;\r\n            }\r\n            return this.parsedQuery[param] !== undefined;\r\n        },\r\n        getQueryParam(param: string): string | null | undefined {\r\n            if (!query) {\r\n                return undefined;\r\n            }\r\n            return this.parsedQuery[param];\r\n        },\r\n        addQueryParam(param: string, value: string | null = null): void {\r\n            let newQuery: { [key: string]: any } = { ...this.parsedQuery, [param]: value };\r\n            cachedQuery = null;\r\n            query = qs.stringify(newQuery);\r\n            if (query) {\r\n                query = \"?\" + query;\r\n            }\r\n        },\r\n        removeQueryParam(param: string): void {\r\n            if (!query) {\r\n                return;\r\n            }\r\n            let parsedQuery: { [key: string]: any } = this.parsedQuery;\r\n            delete parsedQuery[param];\r\n            this.query = qs.stringify(parsedQuery);\r\n        }\r\n    };\r\n}\r\n\r\nfunction emitSingle(router: GenericRouter, location?: ILocation): void {\r\n    // se non Ã¨ disponibile `location` recuperare l'attuale\r\n    let path: string;\r\n    if (location) {\r\n        path = location.pathname;\r\n    } else {\r\n        location = getLocation();\r\n        path = location.pathname;\r\n    }\r\n    // path = PathGenerator.prepare(path); // it is done inside location, is it needed here?\r\n    let redirection: { location: ILocation, keymap: KeyMap } | null = null;\r\n    // check if this route should be redirected\r\n    router[REDIRECTIONS].some(redirectionRoute => {\r\n        let exec: RegExpExecArray | null = redirectionRoute.regex.exec(path as string);\r\n        if (exec) {\r\n            redirection = { location: location as ILocation, keymap: KeyMapFrom(redirectionRoute.keys, exec.slice(1)) };\r\n            location = getLocation(redirectionRoute.redirection);\r\n            path = location.pathname;\r\n            return false;\r\n        }\r\n        return false;\r\n    });\r\n    router[ROUTES].some(route => {\r\n        let exec: RegExpExecArray | null = route.regex.exec(path as string);\r\n        if (exec) {\r\n            route.callback(location as ILocation, KeyMapFrom(route.keys, exec.slice(1)), redirection);\r\n            return true;\r\n        }\r\n        return false;\r\n    });\r\n}\r\nfunction _emit(): void {\r\n    let location: ILocation = getLocation();\r\n    routers.forEach(router => {\r\n        emitSingle(router, location);\r\n    });\r\n}\r\n\r\nlet emitRoute: boolean = true;\r\nfunction onland(): void {\r\n    if (emitRoute) {\r\n        _emit();\r\n    } else {\r\n        emitRoute = true;\r\n    }\r\n}\r\nwindow.addEventListener(\"historylanded\", onland);\r\n\r\nfunction _go(path: string, replace: boolean = false, emit: boolean = true): Promise<void | undefined> {\r\n    let lastEmitRoute: boolean = emitRoute;\r\n    emitRoute = emit;\r\n    return (replace ? HistoryManager.replace(path) : HistoryManager.assign(path)).catch(() => {\r\n        emitRoute = lastEmitRoute;\r\n    });\r\n}\r\n\r\nfunction _throwIfDestroyed(router: GenericRouter): void {\r\n    if (router[DESTROYED]) {\r\n        throw new Error(\"Router destroyed\");\r\n    }\r\n}\r\nclass GenericRouter {\r\n    constructor() {\r\n        routers.push(this);\r\n    }\r\n    [ROUTES]: Array<IRoute> = [];\r\n    [REDIRECTIONS]: Array<IRedirectionRoute> = [];\r\n    [DESTROYED]: boolean = false;\r\n    destroy(): void {\r\n        if (this[DESTROYED]) {\r\n            return;\r\n        }\r\n        let index: number = routers.indexOf(this);\r\n        if (index > -1) {\r\n            routers.splice(index, 1);\r\n        }\r\n        this[DESTROYED] = true;\r\n    }\r\n    /**\r\n     * Segna il percorso specificato come reindirizzamento ad un altro\r\n     * @param path\r\n     * @param redirection\r\n     */\r\n    redirect(path: string, redirection: string): RegExp {\r\n        _throwIfDestroyed(this);\r\n        let keys: Array<Key> = [];\r\n        let regex: RegExp = PathGenerator.generate(path, keys);\r\n        this[REDIRECTIONS].push({ regex, keys, redirection: PathGenerator.prepare(redirection) });\r\n        return regex;\r\n    }\r\n    /**\r\n     * Elimina un reindirizzamento\r\n     * @param path\r\n     */\r\n    unredirect(path: string): void {\r\n        _throwIfDestroyed(this);\r\n        let keys: Array<Key> = [];\r\n        let regex: RegExp = PathGenerator.generate(path, keys);\r\n        let rIndex: number = -1;\r\n        this[ROUTES].some((route, index) => {\r\n            let xSource: string = (regex.ignoreCase ? regex.source.toLowerCase() : regex.source);\r\n            let ySource: string = (route.regex.ignoreCase ? route.regex.source.toLowerCase() : route.regex.source);\r\n            if ((xSource === ySource) && (regex.global === route.regex.global) &&\r\n                (regex.ignoreCase === route.regex.ignoreCase) && (regex.multiline === route.regex.multiline)\r\n            ) {\r\n                rIndex = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        if (rIndex > -1) {\r\n            this[ROUTES].splice(rIndex, 1);\r\n        }\r\n    }\r\n    /**\r\n     * Associa una funzione ad un percorso\r\n     * @param path\r\n     * @param callback\r\n     */\r\n    route(path: string, callback: IRouteCallback): RegExp {\r\n        _throwIfDestroyed(this);\r\n        let keys: Array<Key> = [];\r\n        let regex: RegExp = PathGenerator.generate(path, keys);\r\n        this[ROUTES].push({ regex, keys, callback });\r\n        return regex;\r\n    }\r\n    /**\r\n     * Elimina la funzione associata al percorso\r\n     * @param path\r\n     */\r\n    unroute(path: string): void {\r\n        _throwIfDestroyed(this);\r\n        let keys: Array<Key> = [];\r\n        let regex: RegExp = PathGenerator.generate(path, keys);\r\n        let rIndex: number = -1;\r\n        this[ROUTES].some((route, index) => {\r\n            let xSource: string = (regex.ignoreCase ? regex.source.toLowerCase() : regex.source);\r\n            let ySource: string = (route.regex.ignoreCase ? route.regex.source.toLowerCase() : route.regex.source);\r\n            if ((xSource === ySource) && (regex.global === route.regex.global) &&\r\n                (regex.ignoreCase === route.regex.ignoreCase) && (regex.multiline === route.regex.multiline)\r\n            ) {\r\n                rIndex = index;\r\n                return true;\r\n            }\r\n            return false;\r\n        });\r\n        if (rIndex > -1) {\r\n            this[ROUTES].splice(rIndex, 1);\r\n        }\r\n    }\r\n    emit(): void {\r\n        emitSingle(this);\r\n    }\r\n}\r\n\r\n// interface IMainRouter extends GenericRouter {\r\n//     /**\r\n//      * Crea un router separato dal principale\r\n//      */\r\n//     create(): GenericRouter;\r\n//     setQueryParam(param: string, value: string | null | undefined, options?: { replace?: boolean, emit?: boolean }): Promise<undefined>;\r\n//     go(path: string, options?: { replace?: boolean, emit?: boolean }): Promise<undefined>;\r\n//     go(index: number, options?: { emit: boolean }): Promise<undefined>;\r\n//     base: string;\r\n//     location: ILocation;\r\n//     /**\r\n//      * Blocca la navigazione\r\n//      */\r\n//     lock(/* ghost?: boolean */): Promise<NavigationLock.Lock>;\r\n//     /**\r\n//      * Sblocca la navigazione\r\n//      */\r\n//     unlock(force?: boolean): boolean;\r\n//     locked: boolean;\r\n//     getContext(href?: string): string | null;\r\n//     /**\r\n//      * Associa un percorso ad un contesto\r\n//      * @param context\r\n//      * @param href\r\n//      * @param isFallbackContext\r\n//      * @param canChain\r\n//      */\r\n//     addContextPath(context: string, href: string, isFallbackContext?: boolean, canChain?: boolean): RegExp;\r\n//     /**\r\n//      * Imposta il percorso predefinito di un contesto\r\n//      * @param context\r\n//      * @param href\r\n//      */\r\n//     setContextDefaultHref(context: string, href: string): void;\r\n//     /**\r\n//      * Imposta un contesto\r\n//      * @param this\r\n//      * @param context\r\n//      */\r\n//     setContext(context: {\r\n//         name: string,\r\n//         paths: { path: string, fallback?: boolean }[],\r\n//         default?: string\r\n//     }): void;\r\n//     restoreContext(context: string, defaultHref?: string): Promise<void>;\r\n//     emit(single?: boolean): void;\r\n//     // start(startingContext: string, organizeHistory?: boolean): boolean;\r\n//     start(startingContext: string): void;\r\n//     getLocationAt(index: number): ILocation | null;\r\n//     index(): number;\r\n// }\r\n\r\nlet main: GenericRouter = new GenericRouter();\r\n\r\nexport function redirect(path: string, redirection: string): RegExp {\r\n    return main.redirect(path, redirection);\r\n}\r\nexport function unredirect(path: string): void {\r\n    return main.unredirect(path);\r\n}\r\nexport function route(path: string, callback: IRouteCallback): RegExp {\r\n    return main.route(path, callback);\r\n}\r\nexport function unroute(path: string): void {\r\n    return main.unroute(path);\r\n}\r\n// :TODO:\r\n// main.start = function (startingContext: string, organizeHistory: boolean = true): boolean {\r\nexport function start (startingContext: string): void {\r\n    return HistoryManager.start(startingContext);\r\n}\r\nexport function index(): number {\r\n    return HistoryManager.index();\r\n}\r\nexport function getLocationAt(index: number): ILocation | null {\r\n    let href: string | null = HistoryManager.getHREFAt(index);\r\n    if (href == null) {\r\n        return null;\r\n    }\r\n    return getLocation(href);\r\n}\r\nexport function addContextPath(context: string, href: string, isFallback: boolean = false): RegExp {\r\n    return HistoryManager.addContextPath(context, href, isFallback);\r\n}\r\nexport function setContextDefaultHref(context: string, href: string): void {\r\n    return HistoryManager.setContextDefaultHref(context, href);\r\n}\r\nexport function setContext(context: {\r\n    name: string,\r\n    paths: { path: string, fallback?: boolean }[],\r\n    default?: string\r\n}): void {\r\n    return HistoryManager.setContext(context);\r\n}\r\nexport function getContext(href?: string): string | null {\r\n    return HistoryManager.getContext(href);\r\n}\r\nexport function restoreContext(context: string, defaultHref?: string): Promise<void> {\r\n    return HistoryManager.restore(context);\r\n}\r\nexport function emit(single: boolean = false): void {\r\n    if (single) {\r\n        return emitSingle(main);\r\n    }\r\n    return _emit();\r\n}\r\nexport function create(): GenericRouter {\r\n    return new GenericRouter();\r\n}\r\nexport function go(path_index: string | number, options: {\r\n    emit: boolean\r\n    replace?: boolean,\r\n}): Promise<undefined> {\r\n    // tslint:disable-next-line: typedef\r\n    let path_index_type = typeof path_index;\r\n    if (path_index_type !== \"string\" && path_index_type !== \"number\") {\r\n        throw new Error(\"router.go should receive an url string or a number\");\r\n    }\r\n    // let promiseResolve: () => void;\r\n    options = { ...options };\r\n    return new Promise((promiseResolve: () => void, promiseReject: () => void) => {\r\n        let goingEvent: CustomEvent<{\r\n            direction: string | number, replace?: boolean, emit: boolean\r\n        }> = new CustomEvent<{ direction: string | number, replace?: boolean, emit: boolean }>(\r\n            \"router:going\",\r\n            {\r\n                detail: {\r\n                    direction: path_index,\r\n                    ...options\r\n                },\r\n                cancelable: true\r\n            }\r\n        );\r\n        window.dispatchEvent(goingEvent);\r\n        if (goingEvent.defaultPrevented) {\r\n            promiseReject();\r\n            return;\r\n        }\r\n        if (path_index_type === \"string\") {\r\n            _go(\r\n                path_index as string,\r\n                (options && options.replace) || false,\r\n                (options == null || options.emit == null) ? true : options.emit\r\n            ).then(promiseResolve);\r\n        } else {\r\n            let lastEmitRoute: boolean = emitRoute;\r\n            emitRoute = options.emit == null ? true : options.emit;\r\n            HistoryManager.go(path_index as number).then(promiseResolve, () => {\r\n                emitRoute = lastEmitRoute;\r\n            });\r\n        }\r\n    });\r\n}\r\nexport function setQueryParam(param: string, value: string | null | undefined, options: {\r\n    emit: boolean,\r\n    replace?: boolean\r\n}): Promise<undefined> {\r\n    let promiseResolve: () => void;\r\n    let promise: Promise<undefined> = new Promise(resolve => { promiseResolve = resolve;});\r\n    HistoryManager.onWorkFinished(() => {\r\n        let location: ILocation = getLocation();\r\n        if (value === undefined) {\r\n            location.removeQueryParam(param);\r\n        } else {\r\n            location.addQueryParam(param, value);\r\n        }\r\n        go(location.href, options).then(promiseResolve);\r\n    });\r\n    return promise;\r\n}\r\nexport function lock(): Promise<NavigationLock.Lock> {\r\n    return NavigationLock.lock();\r\n}\r\nexport function unlock(force: boolean = true): boolean {\r\n    return NavigationLock.unlock(force);\r\n}\r\nexport function destroy(): void {\r\n    throw new Error(\"cannot destroy main Router\");\r\n}\r\nexport function getBase(): string {\r\n    return URLManager.base();\r\n}\r\nexport function setBase(newBase: string): void {\r\n    URLManager.base(newBase.replace(/[\\/]+$/, \"\"));\r\n    _emit();\r\n}\r\nexport function isLocked(): boolean {\r\n    return NavigationLock.locked();\r\n}\r\n\r\nexport type Redirection = { location: ILocation, keymap: KeyMap };\r\nexport * as NavigationLock from \"./NavigationLock\";","interface ILock {\r\n    release(): void;\r\n    beginRelease(start_fn: () => void): void;\r\n    readonly releasing: boolean;\r\n    readonly released: boolean;\r\n    onrelease<T>(callback: (this: T) => void, context?: T): void;\r\n}\r\n\r\nlet locks: ILock[] = [];\r\nexport function lock(locking_fn: (this: ILock, lock: ILock) => boolean | void): Promise<ILock> {\r\n    let released: boolean = false;\r\n    let releasing: boolean = false;\r\n    let onrelease: [() => void, any][] = [];\r\n    let promise: Promise<ILock>;\r\n    let lock: ILock = {\r\n        get released(): boolean {\r\n            return released;\r\n        },\r\n        get releasing(): boolean {\r\n            return releasing;\r\n        },\r\n        release(): void {\r\n            if (released) {\r\n                return;\r\n            }\r\n            released = true;\r\n            releasing = false;\r\n\r\n            let i: number = locks.length - 1;\r\n            for (; i >= 0; i--) {\r\n                if (locks[i] === lock) {\r\n                    locks.splice(i, 1);\r\n                    break;\r\n                }\r\n            }\r\n            if (i >= 0) {\r\n                onrelease.forEach(([callback, context]) => {\r\n                    callback.call(context || null);\r\n                });\r\n            }\r\n        },\r\n        beginRelease(start_fn: () => void): void {\r\n            releasing = true;\r\n            start_fn();\r\n        },\r\n        onrelease<T>(callback: (this: T) => void, context: T = null as any): void {\r\n            onrelease.push([callback, context || null]);\r\n        }\r\n    };\r\n    return promise = new Promise<ILock>(resolve => {\r\n        ondone(() => {\r\n            let result: boolean | void = locking_fn.call(lock, lock);\r\n            locks.push(lock);\r\n            if (result !== false && result !== void 0) {\r\n                lock.release();\r\n            }\r\n            resolve(lock);\r\n        });\r\n    });\r\n}\r\n\r\nexport function locked(): boolean {\r\n    return locks.length > 0 && locks.every(lock => !lock.releasing && !lock.released);\r\n}\r\n\r\nlet currentWork: number = -1;\r\nlet working: number = 0;\r\nlet ondoneCallbacks: [() => void, any][] = [];\r\nfunction completeWork(): void {\r\n    if (currentWork === -1) {\r\n        return;\r\n    }\r\n    if (--working === 0) {\r\n        currentWork = -1;\r\n        while (ondoneCallbacks.length && currentWork === -1) {\r\n            let [callback, context] = ondoneCallbacks.shift();\r\n            callback.call(context || null);\r\n        }\r\n    }\r\n}\r\n\r\nfunction ondoneWork<T>(fn: (this: T) => void, context: T, workId: number): void {\r\n    if (currentWork !== -1 && currentWork !== workId) {\r\n        ondoneCallbacks.push([fn, context || null]);\r\n        return;\r\n    }\r\n    fn.call(context || null as any);\r\n}\r\n\r\nexport function startWork(start_fn: (complete: () => void, id: number) => void, id: number = Date.now()): number {\r\n    if (locked()) {\r\n        console.error(\"navigation is locked\");\r\n        return -1;\r\n    }\r\n    let completed: boolean = false;\r\n    ondoneWork(() => {\r\n        currentWork = id;\r\n        working++;\r\n        start_fn(() => {\r\n            if (completed) {\r\n                return;\r\n            }\r\n            completed = true;\r\n            completeWork();\r\n        }, id);\r\n    }, null, id);\r\n    return id;\r\n}\r\n\r\nexport function ondone<T>(fn: (this: T) => void, context?: T): void {\r\n    if (working) {\r\n        ondoneCallbacks.push([fn, context || null]);\r\n        return;\r\n    }\r\n    fn.call(context || null as any);\r\n}"],"names":["URLManager.get","PathGenerator.prepare","qs.parse","qs.stringify","HistoryManager.replace","HistoryManager.assign","PathGenerator.generate","HistoryManager.start","HistoryManager.index","HistoryManager.getHREFAt","HistoryManager.addContextPath","HistoryManager.setContextDefaultHref","HistoryManager.setContext","HistoryManager.getContext","HistoryManager.restore","HistoryManager.go","HistoryManager.onWorkFinished","NavigationLock.lock","NavigationLock.unlock","URLManager.base","NavigationLock.locked","lock","__read"],"mappings":"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"}